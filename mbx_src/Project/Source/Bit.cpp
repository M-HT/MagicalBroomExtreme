//======================================================================================
//======================================================================================
//
//
//			ビット
//
//
//======================================================================================
//======================================================================================


//======================================================================================
//	include
//======================================================================================
#include "Bit.h"
#include "BitBlur.h"
#include "EnemyFx.h"
#include "Sound.h"


long CBIT::BitNum = 0;
long CBIT::BitCount = 0;

//======================================================================================
//
//	コンストラクタ
//
//======================================================================================
CBIT::CBIT( float x, float y, long lv ) : CSPRITE( SORT_PLAYERSHOT )
{
	// レベルごとの最大発射可能数
	const long max[] = { 2, 4, 6, 8 };
	if ( ++BitNum > max[lv] )
	{
		Release();
		return;
	}

	SetHitCount( 5 );

	// サウンド再生
	CSound::Play( SE_BIT );

	// 発射番号ごとの発射角度
	const long angle[] = { -128, 128, -256, 256, -384, 384, -512, 512 };

	Power = 50;
	Px = x;
	Py = y;
	bHit = true;
	Speed = 8;
	Angle = 2048+angle[BitCount];

	++BitCount %= max[lv];
}

//======================================================================================
//
//	処理
//
//======================================================================================
bool CBIT::Action( void )
{
	RECT src = { 736, 446, 768, 478 };

	// 一番近い敵検索
	float x = Px;
	float y = Py;
	ReferenceNear( &x, &y, SORT_ENEMY );

	//------------------------------------------
	// 座標計算
	//------------------------------------------

	// 目標との角度算出
	long a = LunaMath::Atan( (long)(x-Px), (long)(y-Py) );

	// 現在の角度との相対角度算出
	a = Angle - a;
	a &= 4095;

	// 角度に応じた処理
	if ( a > 2048 )	{ Angle += 64; }
	else			{ Angle -= 64; }
	Angle &= 4095;

	// 角度に応じてスピード調整
	if ( a < 256 || a > 4096-256 )
	{
		if ( (Speed += 0.8f) > 12 ) Speed = 12;
	}
	else
	{
		if ( (Speed -= 1.2f) < 4 ) Speed = 4;
	}

	Px += LunaMath::Cos( (long)Angle, (long)Speed );
	Py += LunaMath::Sin( (long)Angle, (long)Speed );

	//-------------------------------------------
	// 描画処理
	//-------------------------------------------
	RECT dest = { (long)Px-8, (long)Py-8, (long)Px+8, (long)Py+8 };

	Sprite[3][0]->Draw( &dest, D3DCOLOR_XRGB(255,255,255), &src );

	//-------------------------------------------
	// あたり判定
	//-------------------------------------------
	lpHitPt[0].x = Px-8;	lpHitPt[0].y = Py-8;
	lpHitPt[1].x = Px+8;	lpHitPt[1].y = Py-8;
	lpHitPt[2].x = Px+8;	lpHitPt[2].y = Py+8;
	lpHitPt[3].x = Px-8;	lpHitPt[3].y = Py+8;
	lpHitPt[4] = lpHitPt[0];

	// 残像
	new CBITBLUR( Px, Py );

	return bDeath;
}

//======================================================================================
//
//	ダメージ
//
//======================================================================================
void CBIT::Damage( long pow )
{
	CSound::Play( SE_BIT );
	bHit = false;
	bDeath = true;
	// 破片散らし
	for ( long i = 0; i < 16; i++ )
	{
		long angle = i * 4096 / 16;
		new CENEMYFX( Px, Py, 1, angle, D3DCOLOR_XRGB(255,255,255) );
	}
}